### 链表

单链表的优势：对于插入和删除数据频繁的操作，单链表的效率更高

比如在第i个位置插入10个数据，第一次为O(n),后面几次都为O(1)

插入2步：s.next = q, p.next = s

删除1步：p.next = p.next.next



堆

堆，是对于每一个父节点上的值都小于或等于子节点的值的二叉树

首项`heap[0]`总是最小的一项

heapify(x) 是将二叉树转化为堆的数据结构，时间复杂度O（n）

## Search

索引

稠密索引：在线性索引中，将数据集中的每个记录对应一个索引项，索引项按照关键码有序排列。缺点是因为索引项与数据集的记录个数相同，空间代价大

分块索引：块内无序，块见有序（第二块所有纪录关键字大于第一块）。查找的时候先用折半或插值在找到所在块，在块内因为无序用顺序查找。平均查找长度为O(根号n+1)

倒排索引：(inverted index) 不是由纪录来确定属性值，而是根据属性值确定记录的位置。优点是查找记录非常快，缺点是记录号不定长。



二叉排序树(BST) 也叫二叉搜索树，二叉查找树

有序的线性表，查找效率高，但是插入和删除效率低

(查找时需要插入或删除的查找表称为动态查找表)

目标是在查找和插入同样高效

*平衡二叉树：首先是二叉排序树，其中每个节点的左子树与与右子树高度相差最多为1



多路查找树(B树) (Multi-way search tree) 每个节点的子节点可以与多两个，且每个节点可以存储多个原色

目的：为了降低对外存设备的访问次数

2-3树: 每个节点有两个或三个子节点，一个2节点包含一个元素和两个子节点，一个3节点包含一小一大两个元素和三个子节点

特点是所有字节点在同一个层次

2-3-4树: 是2-3树的拓展

B树: 2-3树和2-3-4树是B树的特例

如果根节点不是叶节点，则至少有两棵子树

每一个非根节点的分支节点，都有k-1个元素和k个子节点

所有叶节点在同一个层次

每块是按照顺序来存储的

优点：由于B树每节点可以具有比二叉树多得多的元素，所以减少了必须访问节点和数据块的数量，从而提高性能。B树是为内外存数据交互准备的

B+树: 对B树缺陷的修复



散列表(哈希表)

散列技术既是一种存储方法，也是一种查找方法

散列技术最适合的问题就是查找与给定值相等的记录

好的散列函数的原则：计算简单，散列地址分布均匀

线性函数，抽取（手机号后四位），平方取中间几位，mod取余数，随机数

冲突解决：

开放定址法：一旦发生冲突，寻找下一个空的散列地址，只要散列表足够大

再散列函数法，每当发生冲突，换一个散列函数计算。

链地址放：给单链表增加节点，好处是绝对可以找到地址，坏处是增加了遍历单链表的性能损耗

公共溢出区法：冲突的存储到溢出表中，基本表找不到，则取溢出表中找

优点：散列表回避了反复比较的繁琐，对与查找性能要求高，记录之间关系无要求的数据非常适用





## Sorting

内排序：待排序得所有记录放在内存中

外排序：整个排序过程需要在内外存之间多次交换数据



冒泡排序：每次选出最大得放到最后一位。两两比较相邻得记录，如果反序则交换，知道没有反序得记录为止

选择排序：每次找到最小得元素放第一位

插入排序：每次将后面的牌插到前面已经排好序的牌中



希尔排序：是插入排序得改进版本 时间复杂度为 O(nlogn)

堆排序：时间复杂度为 O(nlogn)

归并排序：建立一个merge函数把左右两个数组按序加入新的数组，进行二分递归。时间复杂度为 O(nlogn)，空间复杂度O(n+logn). 优点效率高且稳定，缺点是比较占用内存

快速排序： 通过一趟排序讲分成大小两部分，递归对这两部分分别进行继续排序。时间复杂度为 O(nlogn)，空间复杂度O(logn).

## Stack and Queue

栈(stack)

栈是限定仅在表尾进行插入和删除操作的线性表

缺陷：栈必须事先确定数组存储空间大小

当两个栈需求有相反关系时，两栈在一个数组中共享空间

push 和 pop 都很简单，时间复杂度为O(1)



迭代：使用循环结构，不需要反复调用函数和占用额外内存。

递归：使用选择结构，更清晰，简洁，容易理解。消耗时间和内存



后缀表达式：遇到数字就进栈，遇到符号就对栈顶的两个计算，结果进栈

中缀转后缀：遇到数字就输出，遇到符号就进展，前提与栈顶元素比较，如果低则输出栈顶元素，然后进栈



队列：只允许一端进行插入，另一端进行删除 FIFO

入队时间复杂度为O(1)，出队时间复杂度为O(n)

循环队列：解决假溢出问题

链式结构：就是线性表的单链表，但是只能尾进头出，简称链队列

可以确定长度的时候，用循环队列，无法确定用链队列

## String

KMP模式匹配算法：遍历的时候找到已匹配的字数-对应的部分匹配值

[http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html](http://www.ruanyifeng.com/blog/2013/05/Knuth–Morris–Pratt_algorithm.html)





优势 项目 相关经验



优势：熟悉Python, Java 语言，机器学习与深度学习

项目：参与过软件设计，开发，维护，测试等流程。熟悉并参与过现代软件开发模式。





